# LeetCode 1071 – Greatest Common Divisor of Strings

**Difficulty:** Easy

**Topics:** String

**Problem Link:** [1071 - Greatest Common Divisor of Strings](https://leetcode.com/problems/greatest-common-divisor-of-strings/)

---

## Problem Statement

You are given two strings `str1` and `str2`.
Return the largest string `x` such that:

1. `x` divides both `str1` and `str2`.
2. A string `t` divides another string `s` if and only if `s` is formed by concatenating `t` with itself one or more times.

---

## Examples

### Example 1

**Input:** `str1 = "ABAB"`, `str2 = "AB"`
**Output:** `"AB"`

### Example 2

**Input:** `str1 = "LEET"`, `str2 = "CODE"`
**Output:** `""`

---

## Java Solution

```java
class Solution {
    public String gcdOfStrings(String str1, String str2) {
        if (!(str1 + str2).equals(str2 + str1)) {
            return "";
        }

        int g = gcd(str1.length(), str2.length());
        return str1.substring(0, g);
    }

    private int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }
}
```

---

## Explanation
- First, we check whether both strings can actually have a common divisor string. This is done by concatenating the strings in both possible orders and comparing the results. 

```java if (!(str1 + str2).equals(str2 + str1)) ``` 

- Here, we first concatenate `str1` and `str2`.  
  For example, if `str1 = "ABC"` and `str2 = "ABCABC"`, then:

  - `str1 + str2 = "ABCABCABC"`
  - `str2 + str1 = "ABCABCABC"`

- The `.equals()` method checks whether both concatenated strings are **exactly the same**, character by character.

- The condition is negated because if these two results are **not equal**, it means the strings do not follow the same repeating pattern. In such a case, there is no string that can divide both `str1` and `str2`, so we immediately return an empty string.

- After confirming that a common repeating pattern is possible, we move to the core logic of the solution by passing the lengths of both strings to the `gcd()` function.

- The `gcd()` method computes the **greatest common divisor** of the two string lengths. This step is important because any string that divides both `str1` and `str2` must have a length that divides both of their lengths.

- Once we obtain the GCD value, we extract a substring from `str1` starting at index `0` and ending at index `g`. This substring represents the **largest possible string** that can be repeated to form both `str1` and `str2`.

- The `gcd()` function uses the **Euclidean algorithm**, where the problem is repeatedly reduced using the remainder operation until one of the values becomes zero. The remaining value is the GCD.

- Overall, this approach first **filters out invalid cases**, then **uses mathematics to determine the maximum possible divisor length**, and finally **extracts the correct answer efficiently without brute-force checking**.
  
## Time Complexity

- Overall time complexity is `O(n + m)`, where `n` and `m` are the lengths of `str1` and `str2`.  
- The main step that dominates the runtime is the concatenation check `(str1 + str2).equals(str2 + str1)`,  
  which ensures both strings follow the same repeating pattern.  
- After that, the GCD of the lengths is calculated using the Euclidean algorithm, which is very fast (`O(log(min(n, m)))`) compared to the concatenation.  
- Finally, extracting the substring of length `g = gcd(n, m)` is `O(g)`, which is ≤ `min(n, m)`.  
- Combining these, the overall time remains `O(n + m)`.

## Space Complexity

- Overall space complexity is `O(n + m)`.  
- This comes from creating the concatenated strings `(str1 + str2)` and `(str2 + str1)` of length `n + m`.  
- The substring of length `g = gcd(n, m)` also uses additional space, though smaller.  
- No extra data structures are used, so total space is dominated by the strings themselves.

---

## Key Takeaways

1. Combines string properties and number theory efficiently.
2. Concatenation check quickly determines if a common divisor exists.
3. Using GCD of lengths gives the maximum possible divisor string.
4. Avoids brute-force checking of all prefixes, making it optimal.
