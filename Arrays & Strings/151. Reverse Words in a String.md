# LeetCode 151. Reverse Words in a String

**Difficulty:** Medium

**Topics:** Two Pointers, String

**Problem Link:** [151. Reverse Words in a String](https://leetcode.com/problems/reverse-words-in-a-string/description/)

---
## Explanation
Given an input string `s`, reverse the order of the **words**.

A **word** is defined as a sequence of non-space characters. The **words** in `s` will be separated by at least one space.

Return _a string of the words in reverse order concatenated by a single space._

**Note** that `s` may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.

## Examples 

**Example 1:**
**Input**: s = "the sky is blue"

**Output**: "blue is sky the"

**Example 2:**

**Input**: s = "  hello world  "

**Output**: "world hello"

**Explanation**: Your reversed string should not contain leading or trailing spaces.


**Example 3:**

**Input**: s = "a good   example"

**Output**: "example good a"

**Explanation**: You need to reduce multiple spaces between two words to a single space in the reversed string.

---

## Java Solution

```java
class Solution {
    public String reverseWords(String s) {

        s = s.trim().replaceAll("\\s+", " ");
        String[] words = s.split(" ");

        StringBuilder sb = new StringBuilder();

        for(int i = words.length - 1; i >= 0; i--) {
            sb.append(words[i]);
            if(i != 0) sb.append(" ");
        }
        return sb.toString();
    }
}
```

---

## Approach

- The problem statement requires us to reverse the words of the entered strings, whilst also handling the edge cases, such as multiple spaces in a string, leading/ trailing spaces, or an empty string.
- The entered string first should be **cleaned** to remove any leading or trailing spaces.
- Also any **consecutive spaces should be replaced with a single space**, ensuring that we do not get empty words when splitting.
- Then we proceed to **break the string into an array** using spaces as separators.
- The use of `StringBuilder` allows us to append the words from the end of the array without creating a new ojbect in the memory.
- Then the strings are joined with spaces between words and **returned as a single string.**

## Explanation 

- The entered string is first cleaned to remove any leading or trailing spaces via this `s = s.trim().replaceAll("\\s+", " ");`.
  * The `trim()` method **removes all the spaces** that are present at the **start** and the **end** of the string, _not in between the words_.
  * For example, if the string is `"    hello world    "`, then the `trim()` method would turn it to `"hello world"` .
  * The `replaceAll("\\s+", " ")` replaces all the extra spaces with a single space.
  * The `\\s+` is a regular expression that matches **one or more whitespace characters** anywhere in the string and **replaces** them with a **singular regular space**.
  * For example a string `"hello     world"` would become `"hello world"`.
- The **cleaned string** is now split into **words** separated by **spaces** in an **array** → `String[] words = s.split(" ");`
- An object is initialized of the **StringBuilder** class → `StringBuilder sb = new StringBuilder();`
> **StringBuilder** is being used instead of **String** because in **Java**, **strings are immutable**, and when you perform any operation on them, **Java creates a new string in memory.**
> `StringBuilder` is **mutable**, meaning you can **append, insert, or delete characters without creating new object every time in the memory.**
- A `for` loop is initialized which runs from the **last element** of the array, appending _(adding)_ each word to the `sb` object created.
  * Inside the `for` loop, we run a `if` condition to add a space after appending every word in the `sb` object, except for the last word.
- After the `for` loop runs through the entire array, the `sb` object storing the string is returned.


## Time Complexity

* Let `n` be the length of the input string.
* Cleaning the string (`trim` + `replaceAll`) scans the string once → `O(n)`.
* Splitting into words (`split`) also scans the string → `O(n)`.
* Reversing words with the `for` loop iterates through all words, appending to `StringBuilder` → `O(n)`.
* Converting `StringBuilder` to a string → `O(n)`.

**Overall time complexity:** `O(n)`

## Space Complexity

* Word array from `split` → `O(n)`.
* `StringBuilder` holding the reversed string → `O(n)`.
* Other variables → negligible.

**Overall space complexity:** `O(n)`

## Key Takeaways

1. Cleans input to handle extra spaces and edge cases.
2. Uses **split → reverse → join** strategy for clarity.
3. `StringBuilder` ensures efficient string concatenation.
4. Linear time and space complexity make it suitable for large inputs.
5. Avoids multiple immutable string concatenations, keeping it efficient.
