# LeetCode 345. Reverse Vowels of a String

**Difficulty:** Easy  
**Topics:** Two Pointers, Strings 

**Problem Link:** [345. Reverse Vowels of a String](https://leetcode.com/problems/reverse-vowels-of-a-string/description/)

---

## Problem Statement
Given a string `s`, reverse only all the vowels in the string and return it.

The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.

**Example 1:**
Input: s = `IceCreAm`
Output: `AceCreIm`

**Explanation:**
The vowels in `s` are `['I', 'e', 'e', 'A']`. On reversing the vowels, `s` becomes `"AceCreIm"`.

**Example 2:**
Input: s = `leetcode`
Output: `leotcede` 

---
## Java Solution
```java
class Solution {
    public String reverseVowels(String s) {
        if(s == null || s.isEmpty()) return "";
        
        String vowels = "aeiouAEIOU";
        char[] c = s.toCharArray();
        int i = 0, j = s.length() - 1;

        while (i < j) {
            if(vowels.indexOf(c[i]) == -1) {i++; continue;}
            if(vowels.indexOf(c[j]) == -1) {j--; continue;}

            char temp = c[i];
            c[i++] = c[j];
            c[j--] = temp;
        }
        return new String(c);
    }
}
```
Got it — neutral, professional, and natural. No fluff, no “story-time” tone. Here it is, **clean and human**:

---

## Explanation

* The `reverseVowels` method takes a string `s` and returns a new string where only the vowels are reversed. All non-vowel characters remain in their original positions.
* The initial `if` condition checks for `null` or empty input. In either case, there is nothing to process, so an empty string is returned.
* A string `vowels = "aeiouAEIOU"` is defined to represent all valid vowels, both lowercase and uppercase. This allows for quick vowel checks using `indexOf`.
* The input string is converted into a character array using `toCharArray()` since Java strings are immutable and characters need to be swapped in place.
* Two pointers are initialized:

  * `i` starts at the beginning of the array.
  * `j` starts at the end of the array.
* A `while (i < j)` loop is used to move both pointers toward the center.

  * If `c[i]` is not a vowel, `i` is incremented.
  * If `c[j]` is not a vowel, `j` is decremented.
* When both pointers point to vowels, their values are swapped, and both pointers are moved inward.
* After the loop completes, the modified character array is converted back into a string and returned.

---

## Time Complexity & Space Complexity

### Time Complexity: **O(n)**

The string is traversed using two pointers.

* Each character is checked at most once
* All operations inside the loop run in constant time
* There are no nested loops

As a result, the total time complexity is linear with respect to the length of the string.

---

### Space Complexity: **O(n)**

* A character array of size `n` is created from the input string
* Apart from a few variables, no additional memory is used

Therefore, the space complexity grows linearly with the input size.

---

## Key Takeaways

* The solution uses a two-pointer approach for efficient traversal.
* Only vowels are swapped; all other characters remain unchanged.
* Both uppercase and lowercase vowels are handled.
* The algorithm completes in a single pass over the string.

* The final result depends on whether the number of placed flowers meets or exceeds `n`.
* The solution is **space-efficient**, using constant extra memory and in-place updates.
