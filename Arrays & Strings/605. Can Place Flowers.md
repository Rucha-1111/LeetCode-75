# LeetCode 605. Can Place Flowers

**Difficulty:** Easy  
**Topics:** Arrays, Greedy Approach 

**Problem Link:** [605. Can Place Flowers](https://leetcode.com/problems/can-place-flowers/description/)

---

## Problem Statement
You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in **adjacent** plots.

Given an integer array `flowerbed` containing `0'`s and `1'`s, where `0` means empty and `1` means not empty, and an integer `n`, return `true` if **n new flowers** can be planted in the flowerbed without violating the **no-adjacent-flowers rule** and `false` otherwise.

**Example 1:**

Input: flowerbed = `[1,0,0,0,1]`, n = 1
Output: `true`

**Example 2:**

Input: flowerbed = `[1,0,0,0,1]`, n = 2
Output: `false` 

---
## Java 
```java
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        int count = 0;

        for (int i = 0; i < flowerbed.length; i++) {
            if (flowerbed[i] == 0) {
                boolean left = (i == 0) || (flowerbed[i - 1] == 0);
                boolean right = (i == flowerbed.length - 1) || (flowerbed[i + 1] == 0);

                if (left && right) {
                    flowerbed[i] = 1;
                    count++;
                }
            }
        }
        return count >= n;
    }
}
```

## Explanation
- `canPlaceFlowers` method evaluates the `int` array of `flowerbed` and the `int n` denoting the number of flowers that are to be planted in the flowerbed. The return type of the method is boolean, meaning if the `n` number of flowers can be planted in the `flowerbed`, then the value `true` is returned as the output, if not, then `false` is returned.
  The key constraint in this problem is that _no two flowers can be planted in adjacent plots._
- We start by initiating the variable of `int count = 0` to keep a track of how many flowers can be planted.
- A `for` loop is initiated to iterate from the first plot of the _flowerbed_ array till the last plot.
  * Inside this loop, we have a `if` condition that checks if the current plot in the `flowerbed` is an empty plot or not. If it is, we then proceed to check the plots adjacent to it.
  * `boolean left` checks if the plot left to the _current plot_ is the first plot `(i==0)` or an empty plot `(flowerbed[i - 1] == 0)`. If the plots are empty, then the value of `left` becomes `true` else `false`.
  * `boolean right` checks if the plot right to the _current plot_ is the last plot `(i==flowerbed.length-1)` or an empty plot `(flowerbed[i + 1] == 0)`. If the plots are empty, then the value of `right` becomes `true` else `false`.
- If the values of both `left` and `right` are true, we change the value of _current plot_ to **1** inside the `if` condition. We also 

---
